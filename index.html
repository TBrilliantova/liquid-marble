<canvas id="c"></canvas>

<script id="vertex" type="x-shader/x-vertex">
attribute vec2 position;
varying vec2 vUv;

void main() {
    vUv = position * 0.5 + 0.5;
    gl_Position = vec4(position, 0.0, 1.0);
}
</script>

<script id="fragment" type="x-shader/x-fragment">
precision highp float;

uniform sampler2D u_image;
uniform float u_time;
varying vec2 vUv;

// 2D —à—É–º–∏ –¥–ª—è —Ä—ñ–¥–∏–Ω–Ω–æ–≥–æ —Ä—É—Ö—É
float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
}

// –ø–ª–∞–≤–Ω–∏–π –ø–µ—Ä–ª—ñ–Ω-–ø–æ–¥—ñ–±–Ω–∏–π —à—É–º
float smoothNoise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    
    float a = noise(i);
    float b = noise(i + vec2(1.0, 0.0));
    float c = noise(i + vec2(0.0, 1.0));
    float d = noise(i + vec2(1.0, 1.0));
    
    vec2 u = f*f*(3.0 - 2.0*f);
    return mix(a, b, u.x) +
           (c - a)*u.y*(1.0 - u.x) +
           (d - b)*u.x*u.y;
}

// FBM ‚Äî Fractal noise (–¥–∞—î ‚Äú—Ä—ñ–¥–∏–Ω—É‚Äù)
float fbm(vec2 p) {
    float f = 0.0;
    f += 0.5000 * smoothNoise(p); 
    f += 0.2500 * smoothNoise(p * 2.0);
    f += 0.1250 * smoothNoise(p * 4.0);
    f += 0.0625 * smoothNoise(p * 8.0);
    return f;
}

void main() {
    vec2 uv = vUv;

    // —Ä—É—Ö —à—É–º—É
    float t = u_time * 0.1;

    // —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä—ñ–¥–∏–Ω–Ω–æ—ó –¥–µ—Ñ–æ—Ä–º–∞—Ü—ñ—ó
    float flow1 = fbm(uv * 3.0 + t);
    float flow2 = fbm(uv * 3.0 - t * 0.7);

    // –∫–æ–º–±—ñ–Ω—É—î–º–æ –¥–≤–∞ –ø–æ–ª—è —Ä—É—Ö—É
    vec2 offset = vec2(flow1, flow2) * 0.03;

    // –ø—ñ–¥–º—ñ—à–∞–Ω–∞ —Ç–µ–∫—É—á—ñ—Å—Ç—å
    vec4 color = texture2D(u_image, uv + offset);

    gl_FragColor = color;
}
</script>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// SHADERS
function compileShader(id, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, document.getElementById(id).textContent);
    gl.compileShader(shader);
    return shader;
}

const vertexShader = compileShader("vertex", gl.VERTEX_SHADER);
const fragmentShader = compileShader("fragment", gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// FULLSCREEN TRIANGLE
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([
    -1,-1,  1,-1, -1,1,
    -1,1,   1,-1,  1,1
  ]),
  gl.STATIC_DRAW
);

const position = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(position);
gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

const timeLoc = gl.getUniformLocation(program, "u_time");

// üñºÔ∏è HERE ‚Äî –≤—Å—Ç–∞–≤ –ª—ñ–Ω–∫ –Ω–∞ —Ç–≤–æ—é –∫–∞—Ä—Ç–∏–Ω–∫—É –∑ CodePen Assets!
const imageURL = "MUSIC.png";

const texture = gl.createTexture();
const image = new Image();
image.src = imageURL;
image.onload = () => {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    image
  );
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
};

// Animation
let start = performance.now();
function render() {
  let t = (performance.now() - start) / 1000;
  gl.uniform1f(timeLoc, t);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}

render();
</script>
